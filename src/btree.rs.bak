#![allow(dead_code)]

use crate::{OuterLenStackVec, StackVec, StackVecIntoIter};
use std::borrow::Borrow;
use std::cmp::Ordering;
use std::fmt;
use std::mem;

const B: usize = 6;

const MIN_NUM_ELEMENTS: usize = B - 1;
const MAX_NUM_ELEMENTS: usize = 2 * B - 1;
const MAX_NUM_CHILDREN: usize = 2 * B;

trait OptionExt {
    fn assert_none(&self);
}

impl<T> OptionExt for Option<T> {
    #[inline]
    fn assert_none(&self) {
        assert!(
            self.is_none(),
            "called `Option::unwrap()` on a `None` value",
        );
    }
}

trait BoundClonedExt {
    type Target: Clone;

    fn cloned(&self) -> std::ops::Bound<Self::Target>;
}

impl<T: Clone> BoundClonedExt for std::ops::Bound<&T> {
    type Target = T;

    fn cloned(&self) -> std::ops::Bound<T> {
        match self {
            Self::Unbounded => std::ops::Bound::Unbounded,
            Self::Included(x) => std::ops::Bound::Included((*x).clone()),
            Self::Excluded(x) => std::ops::Bound::Excluded((*x).clone()),
        }
    }
}

struct NodeElements<K: Ord, V> {
    _keys: OuterLenStackVec<K, MAX_NUM_ELEMENTS>,
    _values: OuterLenStackVec<V, MAX_NUM_ELEMENTS>,

    _len: u8,
}

impl<K: Ord, V> NodeElements<K, V> {
    pub fn new() -> Self {
        unsafe { Self::from_raw_parts(OuterLenStackVec::new(), OuterLenStackVec::new(), 0) }
    }

    #[inline]
    pub fn keys(&self) -> &[K] {
        unsafe { self._keys.as_slice(self.len()) }
    }

    #[inline]
    pub fn keys_mut(&mut self) -> &mut [K] {
        unsafe { self._keys.as_slice_mut(self.len()) }
    }

    #[inline]
    pub fn values(&self) -> &[V] {
        unsafe { self._values.as_slice(self.len()) }
    }

    #[inline]
    pub fn values_mut(&mut self) -> &mut [V] {
        unsafe { self._values.as_slice_mut(self.len()) }
    }

    /// Get both `keys` and `values` as mutables at the same.
    #[inline]
    pub fn get_all_mut(&mut self) -> (&mut [K], &mut [V]) {
        let len = self.len();
        unsafe { (self._keys.as_slice_mut(len), self._values.as_slice_mut(len)) }
    }

    #[inline(always)]
    pub fn len(&self) -> usize {
        self._len as _
    }

    unsafe fn set_len(&mut self, len: usize) {
        self._len = len as _;
    }

    #[must_use]
    pub fn push(&mut self, k: K, value: V) -> Option<(K, V)> {
        unsafe {
            let overflow_k = self._keys.push(&mut self.len(), k);
            let mut len = self.len();
            let overflow_value = self._values.push(&mut len, value);
            self.set_len(len);

            match (overflow_k, overflow_value) {
                (Some(overflow_k), Some(overflow_value)) => Some((overflow_k, overflow_value)),
                (None, None) => None,
                _ => unreachable!(),
            }
        }
    }

    #[must_use]
    pub fn insert(&mut self, idx: usize, k: K, value: V) -> Option<(K, V)> {
        unsafe {
            let mut len = self.len();

            let overflow_k = self._keys.insert(&mut len.clone(), idx, k);
            let overflow_value = self._values.insert(&mut len, idx, value);

            self.set_len(len);

            match (overflow_k, overflow_value) {
                (Some(overflow_k), Some(overflow_value)) => Some((overflow_k, overflow_value)),
                (None, None) => None,
                _ => unreachable!(),
            }
        }
    }

    pub fn pop(&mut self) -> Option<(K, V)> {
        unsafe {
            let mut len = self.len();

            let popped_k = self._keys.pop(&mut len.clone());
            let popped_value = self._values.pop(&mut len);

            self.set_len(len);

            match (popped_k, popped_value) {
                (Some(popped_k), Some(popped_value)) => Some((popped_k, popped_value)),
                (None, None) => None,
                _ => unreachable!(),
            }
        }
    }

    pub fn remove(&mut self, idx: usize) -> (K, V) {
        unsafe {
            let mut len = self.len();

            let removed_k = self._keys.remove(&mut len.clone(), idx);
            let removed_value = self._values.remove(&mut len, idx);

            self.set_len(len);

            (removed_k, removed_value)
        }
    }

    fn into_raw_parts(
        self,
    ) -> (
        OuterLenStackVec<K, MAX_NUM_ELEMENTS>,
        OuterLenStackVec<V, MAX_NUM_ELEMENTS>,
        usize,
    ) {
        unsafe {
            let mb = mem::ManuallyDrop::new(self);
            (
                (&mb._keys as *const OuterLenStackVec<K, MAX_NUM_ELEMENTS>).read(),
                (&mb._values as *const OuterLenStackVec<V, MAX_NUM_ELEMENTS>).read(),
                mb._len as _,
            )
        }
    }

    unsafe fn from_raw_parts(
        keys: OuterLenStackVec<K, MAX_NUM_ELEMENTS>,
        values: OuterLenStackVec<V, MAX_NUM_ELEMENTS>,
        len: usize,
    ) -> Self {
        Self {
            _keys: keys,
            _values: values,
            _len: len as _,
        }
    }

    pub fn separate(self) -> (StackVec<K, MAX_NUM_ELEMENTS>, StackVec<V, MAX_NUM_ELEMENTS>) {
        unsafe {
            let (keys, values, len) = self.into_raw_parts();

            (
                StackVec::from_raw_parts(keys, len),
                StackVec::from_raw_parts(values, len),
            )
        }
    }

    pub fn split(&mut self, rightmost_key: K, rightmost_value: V) -> (K, V, Self) {
        assert_eq!(self.len(), MAX_NUM_ELEMENTS);
        unsafe {
            let mut len = self.len();

            let mut right_keys = self
                ._keys
                .split_at(&mut len.clone(), MAX_NUM_ELEMENTS / 2 + 1)
                .into_raw_parts()
                .0;
            let (mut right_values, mut right_len) = self
                ._values
                .split_at(&mut len, MAX_NUM_ELEMENTS / 2 + 1)
                .into_raw_parts();

            right_keys
                .push(&mut right_len.clone(), rightmost_key)
                .assert_none();
            right_values
                .push(&mut right_len, rightmost_value)
                .assert_none();

            let sep_k = self._keys.pop(&mut len.clone()).unwrap();
            let sep_value = self._values.pop(&mut len).unwrap();

            self.set_len(len);

            (
                sep_k,
                sep_value,
                Self::from_raw_parts(right_keys, right_values, right_len),
            )
        }
    }
}

impl<K: Ord, V> Default for NodeElements<K, V> {
    fn default() -> Self {
        Self::new()
    }
}

impl<K: Ord + Clone, V: Clone> Clone for NodeElements<K, V> {
    fn clone(&self) -> Self {
        unsafe {
            Self::from_raw_parts(
                self._keys.clone(self.len()).into_raw_parts().0,
                self._values.clone(self.len()).into_raw_parts().0,
                self.len(),
            )
        }
    }
}

impl<K: Ord + fmt::Debug, V: fmt::Debug> fmt::Debug for NodeElements<K, V> {
    #[inline(always)]
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("NodeData")
            .field("keys", &self.keys())
            .field("values", &self.values())
            .finish()
    }
}

impl<K: Ord, V> Drop for NodeElements<K, V> {
    fn drop(&mut self) {
        while let Some(_) = self.pop() {}
    }
}

#[derive(Debug, Clone)]
enum Children<K: Ord, V> {
    Nodes(StackVec<Box<Node<K, V>>, MAX_NUM_CHILDREN>),
    Leafs(StackVec<Box<NodeElements<K, V>>, MAX_NUM_CHILDREN>),
}

enum OuterLenChildren<K: Ord, V> {
    Nodes(OuterLenStackVec<Box<Node<K, V>>, MAX_NUM_CHILDREN>),
    Leafs(OuterLenStackVec<Box<NodeElements<K, V>>, MAX_NUM_CHILDREN>),
}

#[derive(Debug, Clone)]
enum Child<K: Ord, V> {
    Node(Box<Node<K, V>>),
    Leaf(Box<NodeElements<K, V>>),
}

#[derive(Debug)]
enum ChildRef<'a, K: Ord, V> {
    Node(&'a Node<K, V>),
    Leaf(&'a NodeElements<K, V>),
}

#[derive(Debug)]
enum ChildRefMut<'a, K: Ord, V> {
    Node(&'a mut Node<K, V>),
    Leaf(&'a mut NodeElements<K, V>),
}

#[derive(Debug)]
enum ChildrenSlice<'a, K: Ord, V> {
    Nodes(&'a [Box<Node<K, V>>]),
    Leafs(&'a [Box<NodeElements<K, V>>]),
}

#[derive(Debug)]
enum ChildrenSliceMut<'a, K: Ord, V> {
    Nodes(&'a mut [Box<Node<K, V>>]),
    Leafs(&'a mut [Box<NodeElements<K, V>>]),
}

#[derive(Debug)]
enum ChildrenIter<'a, K: Ord, V> {
    Nodes(std::slice::Iter<'a, Box<Node<K, V>>>),
    Leafs(std::slice::Iter<'a, Box<NodeElements<K, V>>>),
}

#[derive(Debug)]
enum ChildrenIterMut<'a, K: Ord, V> {
    Nodes(std::slice::IterMut<'a, Box<Node<K, V>>>),
    Leafs(std::slice::IterMut<'a, Box<NodeElements<K, V>>>),
}

#[derive(Debug, Clone)]
enum ChildrenIntoIter<K: Ord, V> {
    Nodes(StackVecIntoIter<Box<Node<K, V>>, MAX_NUM_CHILDREN>),
    Leafs(StackVecIntoIter<Box<NodeElements<K, V>>, MAX_NUM_CHILDREN>),
}

impl<K: Ord, V> Child<K, V> {
    pub fn num_elements(&self) -> usize {
        match self {
            Child::Node(node) => node.num_elements(),
            Child::Leaf(leaf) => leaf.len(),
        }
    }

    pub fn as_ref(&self) -> ChildRef<K, V> {
        match self {
            Child::Node(node) => ChildRef::Node(node),
            Child::Leaf(leaf) => ChildRef::Leaf(leaf),
        }
    }

    pub fn as_mut(&mut self) -> ChildRefMut<K, V> {
        match self {
            Child::Node(node) => ChildRefMut::Node(node),
            Child::Leaf(leaf) => ChildRefMut::Leaf(leaf),
        }
    }

    pub fn try_into_node(self) -> Option<Box<Node<K, V>>> {
        match self {
            Self::Node(node) => Some(node),
            Self::Leaf(_) => None,
        }
    }

    pub fn try_into_leaf(self) -> Option<Box<NodeElements<K, V>>> {
        match self {
            Self::Leaf(leaf) => Some(leaf),
            Self::Node(_) => None,
        }
    }

    pub fn try_as_node_ref(&self) -> Option<&Box<Node<K, V>>> {
        match self {
            Self::Node(node) => Some(node),
            Self::Leaf(_) => None,
        }
    }

    pub fn try_as_leaf_ref(&self) -> Option<&Box<NodeElements<K, V>>> {
        match self {
            Self::Leaf(leaf) => Some(leaf),
            Self::Node(_) => None,
        }
    }

    pub fn try_as_node_mut(&mut self) -> Option<&mut Box<Node<K, V>>> {
        match self {
            Self::Node(node) => Some(node),
            Self::Leaf(_) => None,
        }
    }

    pub fn try_as_leaf_mut(&mut self) -> Option<&mut Box<NodeElements<K, V>>> {
        match self {
            Self::Leaf(leaf) => Some(leaf),
            Self::Node(_) => None,
        }
    }

    pub fn keys(&self) -> &[K] {
        match self {
            Child::Node(node) => node.keys(),
            Child::Leaf(leaf) => leaf.keys(),
        }
    }

    pub fn keys_mut(&mut self) -> &mut [K] {
        match self {
            Child::Node(node) => node.keys_mut(),
            Child::Leaf(leaf) => leaf.keys_mut(),
        }
    }

    pub fn values(&self) -> &[V] {
        match self {
            Child::Node(node) => node.values(),
            Child::Leaf(leaf) => leaf.values(),
        }
    }

    pub fn values_mut(&mut self) -> &mut [V] {
        match self {
            Child::Node(node) => node.values_mut(),
            Child::Leaf(leaf) => leaf.values_mut(),
        }
    }

    fn replace_with_child(&mut self) -> bool {
        assert_eq!(self.num_elements(), 0);

        match self {
            Self::Node(node) => unsafe {
                let mut child = node._children.pop(&mut 1).unwrap();
                mem::swap(self, &mut child);

                mem::forget::<Node<K, V>>(match child {
                    Self::Node(node) => *node,
                    Self::Leaf(_) => unreachable!(),
                });

                true
            },
            Self::Leaf(_) => false,
        }
    }
}

impl<'a, K: Ord, V> ChildRef<'a, K, V> {
    pub fn num_elements(&self) -> usize {
        match self {
            ChildRef::Node(node) => node.num_elements(),
            ChildRef::Leaf(leaf) => leaf.len(),
        }
    }

    pub fn keys(&self) -> &[K] {
        match self {
            ChildRef::Node(node) => node.keys(),
            ChildRef::Leaf(leaf) => leaf.keys(),
        }
    }

    pub fn values(&self) -> &[V] {
        match self {
            ChildRef::Node(node) => node.values(),
            ChildRef::Leaf(leaf) => leaf.values(),
        }
    }

    pub fn try_into_node(self) -> Option<&'a Node<K, V>> {
        match self {
            Self::Node(node) => Some(node),
            Self::Leaf(_) => None,
        }
    }

    pub fn try_into_leaf(self) -> Option<&'a NodeElements<K, V>> {
        match self {
            Self::Leaf(leaf) => Some(leaf),
            Self::Node(_) => None,
        }
    }
}

impl<'a, K: Ord, V> Clone for ChildRef<'a, K, V> {
    fn clone(&self) -> Self {
        *self
    }
}

impl<'a, K: Ord, V> Copy for ChildRef<'a, K, V> {}

impl<'a, K: Ord, V> ChildRefMut<'a, K, V> {
    pub fn num_elements(&self) -> usize {
        match self {
            ChildRefMut::Node(node) => node.num_elements(),
            ChildRefMut::Leaf(leaf) => leaf.len(),
        }
    }

    pub fn as_ref(self) -> ChildRef<'a, K, V> {
        match self {
            ChildRefMut::Node(node) => ChildRef::Node(node),
            ChildRefMut::Leaf(leaf) => ChildRef::Leaf(leaf),
        }
    }

    pub fn borrow(&self) -> ChildRef<K, V> {
        match self {
            ChildRefMut::Node(node) => ChildRef::Node(node),
            ChildRefMut::Leaf(leaf) => ChildRef::Leaf(leaf),
        }
    }

    pub fn borrow_mut(&mut self) -> ChildRefMut<K, V> {
        match self {
            ChildRefMut::Node(node) => ChildRefMut::Node(node),
            ChildRefMut::Leaf(leaf) => ChildRefMut::Leaf(leaf),
        }
    }

    pub fn try_into_node(self) -> Option<&'a mut Node<K, V>> {
        match self {
            Self::Node(node) => Some(node),
            Self::Leaf(_) => None,
        }
    }

    pub fn try_into_leaf(self) -> Option<&'a mut NodeElements<K, V>> {
        match self {
            Self::Leaf(leaf) => Some(leaf),
            Self::Node(_) => None,
        }
    }

    pub fn keys(&self) -> &[K] {
        match self {
            ChildRefMut::Node(node) => node.keys(),
            ChildRefMut::Leaf(leaf) => leaf.keys(),
        }
    }

    pub fn values(&self) -> &[V] {
        match self {
            ChildRefMut::Node(node) => node.values(),
            ChildRefMut::Leaf(leaf) => leaf.values(),
        }
    }

    pub fn keys_mut(&mut self) -> &mut [K] {
        match self {
            ChildRefMut::Node(node) => node.keys_mut(),
            ChildRefMut::Leaf(leaf) => leaf.keys_mut(),
        }
    }

    pub fn values_mut(&mut self) -> &mut [V] {
        match self {
            ChildRefMut::Node(node) => node.values_mut(),
            ChildRefMut::Leaf(leaf) => leaf.values_mut(),
        }
    }

    pub fn swap(&mut self, other: ChildRefMut<K, V>) {
        match (self, other) {
            (Self::Node(self_node), ChildRefMut::Node(other_node)) => {
                mem::swap(*self_node, other_node)
            }
            (Self::Leaf(self_leaf), ChildRefMut::Leaf(other_leaf)) => {
                mem::swap(*self_leaf, other_leaf)
            }
            _ => panic!("called `ChildRefMut` where `self` and `other` are different (one is a leaf and the other is a node)"),
        }
    }
}

impl<'a, K: Ord, V> ChildrenSlice<'a, K, V> {
    pub fn get(&self, i: usize) -> Option<ChildRef<'a, K, V>> {
        match self {
            ChildrenSlice::Nodes(nodes) => Some(ChildRef::Node(nodes.get(i)?)),
            ChildrenSlice::Leafs(leafs) => Some(ChildRef::Leaf(leafs.get(i)?)),
        }
    }

    pub fn slice<B: std::ops::RangeBounds<usize>>(&self, bounds: B) -> Option<Self> {
        let bounds = (
            BoundClonedExt::cloned(&bounds.start_bound()),
            BoundClonedExt::cloned(&bounds.end_bound()),
        );

        match self {
            Self::Nodes(nodes) => Some(Self::Nodes(nodes.get(bounds)?)),
            Self::Leafs(leafs) => Some(Self::Leafs(leafs.get(bounds)?)),
        }
    }

    pub fn try_into_nodes(self) -> Option<&'a [Box<Node<K, V>>]> {
        match self {
            Self::Nodes(nodes) => Some(nodes),
            Self::Leafs(_) => None,
        }
    }

    pub fn try_into_leafs(self) -> Option<&'a [Box<NodeElements<K, V>>]> {
        match self {
            Self::Leafs(leafs) => Some(leafs),
            Self::Nodes(_) => None,
        }
    }

    #[inline]
    pub fn iter(&self) -> ChildrenIter<'a, K, V> {
        self.into_iter()
    }
}

impl<'a, K: Ord, V> Clone for ChildrenSlice<'a, K, V> {
    fn clone(&self) -> Self {
        *self
    }
}

impl<'a, K: Ord, V> Copy for ChildrenSlice<'a, K, V> {}

impl<'a, K: Ord, V> IntoIterator for ChildrenSlice<'a, K, V> {
    type Item = ChildRef<'a, K, V>;
    type IntoIter = ChildrenIter<'a, K, V>;

    fn into_iter(self) -> Self::IntoIter {
        match self {
            Self::Nodes(nodes) => ChildrenIter::Nodes(nodes.into_iter()),
            Self::Leafs(leafs) => ChildrenIter::Leafs(leafs.into_iter()),
        }
    }
}

impl<'a, K: Ord, V> ChildrenSliceMut<'a, K, V> {
    pub fn get(&self, i: usize) -> Option<ChildRef<K, V>> {
        match self {
            ChildrenSliceMut::Nodes(nodes) => Some(ChildRef::Node(nodes.get(i)?)),
            ChildrenSliceMut::Leafs(leafs) => Some(ChildRef::Leaf(leafs.get(i)?)),
        }
    }

    pub fn get_mut(&mut self, i: usize) -> Option<ChildRefMut<K, V>> {
        match self {
            ChildrenSliceMut::Nodes(nodes) => Some(ChildRefMut::Node(nodes.get_mut(i)?)),
            ChildrenSliceMut::Leafs(leafs) => Some(ChildRefMut::Leaf(leafs.get_mut(i)?)),
        }
    }

    pub fn drop_get(self, i: usize) -> Option<ChildRef<'a, K, V>> {
        match self {
            ChildrenSliceMut::Nodes(nodes) => Some(ChildRef::Node(nodes.get(i)?)),
            ChildrenSliceMut::Leafs(leafs) => Some(ChildRef::Leaf(leafs.get(i)?)),
        }
    }

    pub fn drop_get_mut(self, i: usize) -> Option<ChildRefMut<'a, K, V>> {
        match self {
            ChildrenSliceMut::Nodes(nodes) => Some(ChildRefMut::Node(nodes.get_mut(i)?)),
            ChildrenSliceMut::Leafs(leafs) => Some(ChildRefMut::Leaf(leafs.get_mut(i)?)),
        }
    }

    pub fn slice<B: std::ops::RangeBounds<usize>>(&self, bounds: B) -> Option<ChildrenSlice<K, V>> {
        let bounds = (
            BoundClonedExt::cloned(&bounds.start_bound()),
            BoundClonedExt::cloned(&bounds.end_bound()),
        );

        match self {
            Self::Nodes(nodes) => Some(ChildrenSlice::Nodes(nodes.get(bounds)?)),
            Self::Leafs(leafs) => Some(ChildrenSlice::Leafs(leafs.get(bounds)?)),
        }
    }

    pub fn slice_mut<B: std::ops::RangeBounds<usize>>(
        &mut self,
        bounds: B,
    ) -> Option<ChildrenSliceMut<K, V>> {
        let bounds = (
            BoundClonedExt::cloned(&bounds.start_bound()),
            BoundClonedExt::cloned(&bounds.end_bound()),
        );

        match self {
            Self::Nodes(nodes) => Some(ChildrenSliceMut::Nodes(nodes.get_mut(bounds)?)),
            Self::Leafs(leafs) => Some(ChildrenSliceMut::Leafs(leafs.get_mut(bounds)?)),
        }
    }

    pub fn drop_slice_mut<B: std::ops::RangeBounds<usize>>(self, bounds: B) -> Option<Self> {
        let bounds = (
            BoundClonedExt::cloned(&bounds.start_bound()),
            BoundClonedExt::cloned(&bounds.end_bound()),
        );

        match self {
            Self::Nodes(nodes) => Some(Self::Nodes(nodes.get_mut(bounds)?)),
            Self::Leafs(leafs) => Some(Self::Leafs(leafs.get_mut(bounds)?)),
        }
    }

    pub fn try_into_nodes(self) -> Option<&'a mut [Box<Node<K, V>>]> {
        match self {
            Self::Nodes(nodes) => Some(nodes),
            Self::Leafs(_) => None,
        }
    }

    pub fn try_into_leafs(self) -> Option<&'a mut [Box<NodeElements<K, V>>]> {
        match self {
            Self::Leafs(leafs) => Some(leafs),
            Self::Nodes(_) => None,
        }
    }

    pub fn iter(&self) -> ChildrenIter<K, V> {
        match self {
            Self::Nodes(nodes) => ChildrenIter::Nodes(nodes.iter()),
            Self::Leafs(leafs) => ChildrenIter::Leafs(leafs.iter()),
        }
    }

    pub fn iter_mut(&mut self) -> ChildrenIterMut<K, V> {
        match self {
            Self::Nodes(nodes) => ChildrenIterMut::Nodes(nodes.iter_mut()),
            Self::Leafs(leafs) => ChildrenIterMut::Leafs(leafs.iter_mut()),
        }
    }

    pub fn swap(&mut self, i: usize, j: usize) {
        match self {
            Self::Nodes(nodes) => {
                nodes.swap(i, j);
            }
            Self::Leafs(leafs) => {
                leafs.swap(i, j);
            }
        }
    }
}

impl<'a, K: Ord, V> IntoIterator for ChildrenSliceMut<'a, K, V> {
    type Item = ChildRefMut<'a, K, V>;
    type IntoIter = ChildrenIterMut<'a, K, V>;

    fn into_iter(self) -> Self::IntoIter {
        match self {
            Self::Nodes(nodes) => ChildrenIterMut::Nodes(nodes.into_iter()),
            Self::Leafs(leafs) => ChildrenIterMut::Leafs(leafs.into_iter()),
        }
    }
}

impl<'a, K: Ord, V> ExactSizeIterator for ChildrenIter<'a, K, V> {
    fn len(&self) -> usize {
        match self {
            Self::Nodes(nodes) => nodes.len(),
            Self::Leafs(leafs) => leafs.len(),
        }
    }
}

impl<'a, K: Ord, V> Iterator for ChildrenIter<'a, K, V> {
    type Item = ChildRef<'a, K, V>;

    fn next(&mut self) -> Option<Self::Item> {
        match self {
            Self::Nodes(nodes_iter) => Some(ChildRef::Node(nodes_iter.next()?)),
            Self::Leafs(leafs_iter) => Some(ChildRef::Leaf(leafs_iter.next()?)),
        }
    }

    fn size_hint(&self) -> (usize, Option<usize>) {
        match self {
            Self::Nodes(nodes) => nodes.size_hint(),
            Self::Leafs(leafs) => leafs.size_hint(),
        }
    }

    fn count(self) -> usize {
        match self {
            Self::Nodes(nodes) => nodes.count(),
            Self::Leafs(leafs) => leafs.count(),
        }
    }

    fn nth(&mut self, n: usize) -> Option<Self::Item> {
        match self {
            Self::Nodes(nodes) => Some(ChildRef::Node(nodes.nth(n)?)),
            Self::Leafs(leafs) => Some(ChildRef::Leaf(leafs.nth(n)?)),
        }
    }

    #[inline]
    fn last(mut self) -> Option<Self::Item> {
        self.next_back()
    }
}

impl<'a, K: Ord, V> DoubleEndedIterator for ChildrenIter<'a, K, V> {
    fn next_back(&mut self) -> Option<Self::Item> {
        match self {
            Self::Nodes(nodes_iter) => Some(ChildRef::Node(nodes_iter.next_back()?)),
            Self::Leafs(leafs_iter) => Some(ChildRef::Leaf(leafs_iter.next_back()?)),
        }
    }

    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
        match self {
            Self::Nodes(nodes_iter) => Some(ChildRef::Node(nodes_iter.nth_back(n)?)),
            Self::Leafs(leafs_iter) => Some(ChildRef::Leaf(leafs_iter.nth_back(n)?)),
        }
    }
}

impl<'a, K: Ord, V> std::iter::FusedIterator for ChildrenIter<'a, K, V> {}

impl<'a, K: Ord, V> Clone for ChildrenIter<'a, K, V> {
    fn clone(&self) -> Self {
        match self {
            Self::Nodes(iter) => Self::Nodes(iter.clone()),
            Self::Leafs(iter) => Self::Leafs(iter.clone()),
        }
    }
}

impl<'a, K: Ord, V> ExactSizeIterator for ChildrenIterMut<'a, K, V> {
    fn len(&self) -> usize {
        match self {
            Self::Nodes(nodes) => nodes.len(),
            Self::Leafs(leafs) => leafs.len(),
        }
    }
}

impl<'a, K: Ord, V> Iterator for ChildrenIterMut<'a, K, V> {
    type Item = ChildRefMut<'a, K, V>;

    fn next(&mut self) -> Option<Self::Item> {
        match self {
            Self::Nodes(nodes_iter) => Some(ChildRefMut::Node(nodes_iter.next()?)),
            Self::Leafs(leafs_iter) => Some(ChildRefMut::Leaf(leafs_iter.next()?)),
        }
    }

    fn size_hint(&self) -> (usize, Option<usize>) {
        match self {
            Self::Nodes(nodes) => nodes.size_hint(),
            Self::Leafs(leafs) => leafs.size_hint(),
        }
    }

    fn count(self) -> usize {
        match self {
            Self::Nodes(nodes) => nodes.count(),
            Self::Leafs(leafs) => leafs.count(),
        }
    }

    fn nth(&mut self, n: usize) -> Option<Self::Item> {
        match self {
            Self::Nodes(nodes) => Some(ChildRefMut::Node(nodes.nth(n)?)),
            Self::Leafs(leafs) => Some(ChildRefMut::Leaf(leafs.nth(n)?)),
        }
    }

    #[inline]
    fn last(mut self) -> Option<Self::Item> {
        self.next_back()
    }
}

impl<'a, K: Ord, V> DoubleEndedIterator for ChildrenIterMut<'a, K, V> {
    fn next_back(&mut self) -> Option<Self::Item> {
        match self {
            Self::Nodes(nodes_iter) => Some(ChildRefMut::Node(nodes_iter.next_back()?)),
            Self::Leafs(leafs_iter) => Some(ChildRefMut::Leaf(leafs_iter.next_back()?)),
        }
    }

    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {
        match self {
            Self::Nodes(nodes_iter) => Some(ChildRefMut::Node(nodes_iter.nth_back(n)?)),
            Self::Leafs(leafs_iter) => Some(ChildRefMut::Leaf(leafs_iter.nth_back(n)?)),
        }
    }
}

impl<'a, K: Ord, V> std::iter::FusedIterator for ChildrenIterMut<'a, K, V> {}

impl<K: Ord, V> OuterLenChildren<K, V> {
    #[must_use]
    #[inline]
    pub unsafe fn push(&mut self, len: &mut usize, child: Child<K, V>) -> Option<Child<K, V>> {
        match (self, child) {
            (Self::Nodes(nodes), Child::Node(node)) => Some(Child::Node(nodes.push(len, node)?)),
            (Self::Leafs(leafs), Child::Leaf(leaf)) => Some(Child::Leaf(leafs.push(len, leaf)?)),
            _ => panic!("called `OuterLenChildren::push` where `self` and `child` are different (one is a leaf and the other is a node)"),
        }
    }

    #[must_use]
    #[inline]
    pub unsafe fn insert(
        &mut self,
        len: &mut usize,
        idx: usize,
        child: Child<K, V>,
    ) -> Option<Child<K, V>> {
        match (self, child) {
            (Self::Nodes(nodes), Child::Node(node)) => {
                Some(Child::Node(nodes.insert(len, idx, node)?))
            }
            (Self::Leafs(leafs), Child::Leaf(leaf)) => {
                Some(Child::Leaf(leafs.insert(len, idx, leaf)?))
            }
            _ => panic!("called `OuterLenChildren::insert` where `self` and `child` are different (one is a leaf and the other is a node)"),
        }
    }

    #[inline]
    pub unsafe fn pop(&mut self, len: &mut usize) -> Option<Child<K, V>> {
        match self {
            Self::Nodes(nodes) => Some(Child::Node(nodes.pop(len)?)),
            Self::Leafs(leafs) => Some(Child::Leaf(leafs.pop(len)?)),
        }
    }

    #[inline]
    pub unsafe fn remove(&mut self, len: &mut usize, idx: usize) -> Child<K, V> {
        match self {
            Self::Nodes(nodes) => Child::Node(nodes.remove(len, idx)),
            Self::Leafs(leafs) => Child::Leaf(leafs.remove(len, idx)),
        }
    }

    #[inline]
    pub unsafe fn split_at(&mut self, len: &mut usize, left_len: usize) -> Children<K, V> {
        match self {
            Self::Nodes(nodes) => Children::Nodes(nodes.split_at(len, left_len)),
            Self::Leafs(leafs) => Children::Leafs(leafs.split_at(len, left_len)),
        }
    }

    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> ChildrenSlice<K, V> {
        match self {
            Self::Nodes(nodes) => ChildrenSlice::Nodes(nodes.as_slice(len)),
            Self::Leafs(leafs) => ChildrenSlice::Leafs(leafs.as_slice(len)),
        }
    }

    #[inline]
    pub unsafe fn as_slice_mut(&mut self, len: usize) -> ChildrenSliceMut<K, V> {
        match self {
            Self::Nodes(nodes) => ChildrenSliceMut::Nodes(nodes.as_slice_mut(len)),
            Self::Leafs(leafs) => ChildrenSliceMut::Leafs(leafs.as_slice_mut(len)),
        }
    }

    pub unsafe fn clone(&self, len: usize) -> Children<K, V>
    where
        K: Clone,
        V: Clone,
    {
        match self {
            Self::Nodes(nodes) => Children::Nodes(nodes.clone(len)),
            Self::Leafs(leafs) => Children::Leafs(leafs.clone(len)),
        }
    }
}

impl<K: Ord, V> Children<K, V> {
    #[inline]
    pub fn len(&self) -> usize {
        match self {
            Self::Nodes(nodes) => nodes.len(),
            Self::Leafs(leafs) => leafs.len(),
        }
    }

    #[must_use]
    pub fn push(&mut self, child: Child<K, V>) -> Option<Child<K, V>> {
        match (self, child) {
            (Self::Nodes(nodes), Child::Node(node)) => Some(Child::Node(nodes.push(node)?)),
            (Self::Leafs(leafs), Child::Leaf(leaf)) => Some(Child::Leaf(leafs.push(leaf)?)),
            _ => panic!("called `Children::push` where `self` and `child` are different (one is a leaf and the other is a node)"),
        }
    }

    #[must_use]
    pub fn insert(&mut self, idx: usize, child: Child<K, V>) -> Option<Child<K, V>> {
        match (self, child) {
            (Self::Nodes(nodes), Child::Node(node)) => {
                Some(Child::Node(nodes.insert(idx, node)?))
            }
            (Self::Leafs(leafs), Child::Leaf(leaf)) => {
                Some(Child::Leaf(leafs.insert(idx, leaf)?))
            }
            _ => panic!("called `Children::insert` where `self` and `child` are different (one is a leaf and the other is a node)"),
        }
    }

    pub fn pop(&mut self) -> Option<Child<K, V>> {
        match self {
            Self::Nodes(nodes) => Some(Child::Node(nodes.pop()?)),
            Self::Leafs(leafs) => Some(Child::Leaf(leafs.pop()?)),
        }
    }

    pub fn remove(&mut self, idx: usize) -> Child<K, V> {
        match self {
            Self::Nodes(nodes) => Child::Node(nodes.remove(idx)),
            Self::Leafs(leafs) => Child::Leaf(leafs.remove(idx)),
        }
    }

    pub fn split_at(&mut self, left_len: usize) -> Self {
        match self {
            Self::Nodes(nodes) => Self::Nodes(nodes.split_at(left_len)),
            Self::Leafs(leafs) => Self::Leafs(leafs.split_at(left_len)),
        }
    }

    pub fn as_slice(&self) -> ChildrenSlice<K, V> {
        match self {
            Self::Nodes(nodes) => ChildrenSlice::Nodes(nodes.as_slice()),
            Self::Leafs(leafs) => ChildrenSlice::Leafs(leafs.as_slice()),
        }
    }

    pub fn as_slice_mut(&mut self) -> ChildrenSliceMut<K, V> {
        match self {
            Self::Nodes(nodes) => ChildrenSliceMut::Nodes(nodes.as_slice_mut()),
            Self::Leafs(leafs) => ChildrenSliceMut::Leafs(leafs.as_slice_mut()),
        }
    }

    unsafe fn from_raw_parts(children: OuterLenChildren<K, V>, len: usize) -> Self {
        match children {
            OuterLenChildren::Nodes(nodes) => Self::Nodes(StackVec::from_raw_parts(nodes, len)),
            OuterLenChildren::Leafs(leafs) => Self::Leafs(StackVec::from_raw_parts(leafs, len)),
        }
    }

    fn into_raw_parts(self) -> (OuterLenChildren<K, V>, usize) {
        match self {
            Self::Nodes(nodes) => {
                let (data, len) = nodes.into_raw_parts();
                (OuterLenChildren::Nodes(data), len)
            }
            Self::Leafs(leafs) => {
                let (data, len) = leafs.into_raw_parts();
                (OuterLenChildren::Leafs(data), len)
            }
        }
    }
}

impl<K: Ord, V> IntoIterator for Children<K, V> {
    type Item = Child<K, V>;
    type IntoIter = ChildrenIntoIter<K, V>;

    fn into_iter(self) -> ChildrenIntoIter<K, V> {
        match self {
            Self::Nodes(nodes) => ChildrenIntoIter::Nodes(nodes.into_iter()),
            Self::Leafs(leafs) => ChildrenIntoIter::Leafs(leafs.into_iter()),
        }
    }
}

impl<K: Ord, V> Iterator for ChildrenIntoIter<K, V> {
    type Item = Child<K, V>;

    fn next(&mut self) -> Option<Self::Item> {
        match self {
            Self::Nodes(nodes) => Some(Child::Node(nodes.next()?)),
            Self::Leafs(leafs) => Some(Child::Leaf(leafs.next()?)),
        }
    }

    fn size_hint(&self) -> (usize, Option<usize>) {
        match self {
            Self::Nodes(nodes) => nodes.size_hint(),
            Self::Leafs(leafs) => leafs.size_hint(),
        }
    }

    fn count(self) -> usize {
        match self {
            Self::Nodes(nodes) => nodes.count(),
            Self::Leafs(leafs) => leafs.count(),
        }
    }
}

impl<K: Ord, V> DoubleEndedIterator for ChildrenIntoIter<K, V> {
    #[inline]
    fn next_back(&mut self) -> Option<Self::Item> {
        match self {
            Self::Nodes(nodes) => Some(Child::Node(nodes.next_back()?)),
            Self::Leafs(leafs) => Some(Child::Leaf(leafs.next_back()?)),
        }
    }
}

impl<K: Ord, V> ExactSizeIterator for ChildrenIntoIter<K, V> {
    #[inline]
    fn len(&self) -> usize {
        match self {
            Self::Nodes(nodes) => nodes.len(),
            Self::Leafs(leafs) => leafs.len(),
        }
    }
}

struct Node<K: Ord, V> {
    _elements: NodeElements<K, V>,
    _children: OuterLenChildren<K, V>,
}

impl<K: Ord, V> Node<K, V> {
    pub fn new(child: Child<K, V>) -> Self {
        unsafe {
            match child {
                Child::Node(node) => {
                    let mut children = OuterLenStackVec::new();
                    children.push(&mut 0, node).assert_none();
                    Self::from_raw_parts(NodeElements::new(), OuterLenChildren::Nodes(children))
                }
                Child::Leaf(leaf) => {
                    let mut children = OuterLenStackVec::new();
                    children.push(&mut 0, leaf).assert_none();
                    Self::from_raw_parts(NodeElements::new(), OuterLenChildren::Leafs(children))
                }
            }
        }
    }

    #[inline]
    pub fn keys(&self) -> &[K] {
        self._elements.keys()
    }

    #[inline]
    pub fn keys_mut(&mut self) -> &mut [K] {
        self._elements.keys_mut()
    }

    #[inline]
    pub fn values(&self) -> &[V] {
        self._elements.values()
    }

    #[inline]
    pub fn values_mut(&mut self) -> &mut [V] {
        self._elements.values_mut()
    }

    #[inline]
    pub fn children(&self) -> ChildrenSlice<K, V> {
        unsafe { self._children.as_slice(self.num_children()) }
    }

    #[inline]
    pub fn children_mut(&mut self) -> ChildrenSliceMut<K, V> {
        unsafe { self._children.as_slice_mut(self.num_children()) }
    }

    #[inline]
    pub fn get_all_mut(&mut self) -> (&mut [K], &mut [V], ChildrenSliceMut<K, V>) {
        let children = unsafe { self._children.as_slice_mut(self.num_children()) };
        let (keys, values) = self._elements.get_all_mut();
        (keys, values, children)
    }

    #[must_use]
    pub fn push(&mut self, k: K, value: V, child: Child<K, V>) -> Option<(K, V, Child<K, V>)> {
        unsafe {
            let mut old_num_children = self.num_children();

            let overflow_element = self._elements.push(k, value);
            let overflow_child = self._children.push(&mut old_num_children, child);

            match (overflow_element, overflow_child) {
                (Some((overflow_k, overflow_value)), Some(overflow_child)) => {
                    Some((overflow_k, overflow_value, overflow_child))
                }
                (None, None) => None,
                _ => unreachable!(),
            }
        }
    }

    #[must_use]
    pub fn insert(
        &mut self,
        idx: usize,
        k: K,
        value: V,
        child: Child<K, V>,
    ) -> Option<(K, V, Child<K, V>)> {
        unsafe {
            let mut old_num_children = self.num_children();

            let overflow_element = self._elements.insert(idx, k, value);
            let overflow_child = self._children.insert(&mut old_num_children, idx + 1, child);

            match (overflow_element, overflow_child) {
                (Some((overflow_k, overflow_value)), Some(overflow_child)) => {
                    Some((overflow_k, overflow_value, overflow_child))
                }
                (None, None) => None,
                _ => unreachable!(),
            }
        }
    }

    pub fn pop(&mut self) -> Option<(K, V, Child<K, V>)> {
        unsafe {
            let mut old_num_children = self.num_children();

            let popped_element = self._elements.pop();

            if let Some((popped_k, popped_value)) = popped_element {
                let popped_child = self._children.pop(&mut old_num_children).unwrap();
                Some((popped_k, popped_value, popped_child))
            } else {
                None
            }
        }
    }

    pub fn remove(&mut self, idx: usize) -> (K, V, Child<K, V>) {
        unsafe {
            let mut old_num_children = self.num_children();

            let (removed_k, removed_values) = self._elements.remove(idx);
            let removed_child = self._children.remove(&mut old_num_children, idx + 1);

            (removed_k, removed_values, removed_child)
        }
    }

    pub fn split(
        &mut self,
        rightmost_k: K,
        rightmost_value: V,
        rightmost_child: Child<K, V>,
    ) -> (K, V, Self) {
        unsafe {
            let mut num_children = self.num_children();

            let (sep_k, sep_value, right_elements) =
                self._elements.split(rightmost_k, rightmost_value);
            let mut right_children = self
                ._children
                .split_at(&mut num_children, self.num_children())
                .into_raw_parts()
                .0;
            right_children
                .push(&mut right_elements.len(), rightmost_child)
                .assert_none();

            //      [kv0| kv1 |kv2] kvr
            // [ch0, ch1||ch2, ch3] chr

            (
                sep_k,
                sep_value,
                Self::from_raw_parts(right_elements, right_children),
            )
        }
    }

    fn into_raw_parts(self) -> (NodeElements<K, V>, OuterLenChildren<K, V>) {
        unsafe {
            let mb = mem::ManuallyDrop::new(self);
            (
                (&mb._elements as *const NodeElements<K, V>).read(),
                (&mb._children as *const OuterLenChildren<K, V>).read(),
            )
        }
    }

    unsafe fn from_raw_parts(
        elements: NodeElements<K, V>,
        children: OuterLenChildren<K, V>,
    ) -> Self {
        Self {
            _elements: elements,
            _children: children,
        }
    }

    pub fn separate(self) -> (NodeElements<K, V>, Children<K, V>) {
        unsafe {
            let num_children = self.num_children();

            let (elements, children) = self.into_raw_parts();

            (elements, Children::from_raw_parts(children, num_children))
        }
    }

    #[inline(always)]
    pub fn num_children(&self) -> usize {
        self.num_elements() + 1
    }
    #[inline(always)]
    pub fn num_elements(&self) -> usize {
        self._elements.len()
    }
}

impl<K: Ord + Clone, V: Clone> Clone for Node<K, V> {
    fn clone(&self) -> Self {
        unsafe {
            Self::from_raw_parts(
                self._elements.clone(),
                self._children.clone(self.num_children()).into_raw_parts().0,
            )
        }
    }
}

impl<K: Ord + fmt::Debug, V: fmt::Debug> fmt::Debug for Node<K, V> {
    #[inline(always)]
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Node")
            // .field("elements", &self._elements)
            .field("keys", &self.keys())
            .field("values", &self.values())
            .field("children", &self.children())
            .finish()
    }
}

impl<K: Ord, V> Drop for Node<K, V> {
    fn drop(&mut self) {
        while let Some(_) = self.pop() {}
        unsafe {
            self._children.pop(&mut 1).unwrap();
        }
    }
}

#[inline]
pub fn lin_search<T, Q>(a: &[T], k: &Q) -> Result<usize, usize>
where
    T: Ord + Borrow<Q>,
    Q: Ord + ?Sized,
{
    lin_search_by(a, |x| x.borrow().cmp(k))
}

#[inline]
pub fn lin_search_by<T, F: FnMut(&T) -> Ordering>(a: &[T], mut f: F) -> Result<usize, usize> {
    // const LIN_SEARCH_SIZE: usize = 20;

    // let mut size = a.len();
    // let mut left = 0;
    // let mut right = size;

    // while LIN_SEARCH_SIZE < size {
    //     let mid = left + size / 2;

    //     let cmp = f(unsafe { a.get_unchecked(mid) });

    //     if cmp == Ordering::Less {
    //         left = mid + 1;
    //     } else if cmp == Ordering::Greater {
    //         right = mid;
    //     } else {
    //         return Ok(mid);
    //     }
    //     size = right - left;
    // }

    for (i, x) in a.iter().enumerate() {
        let cmp = f(x);
        if cmp == Ordering::Greater {
            return Err(i);
        } else if cmp == Ordering::Equal {
            return Ok(i);
        }
    }
    Err(a.len())
}

#[derive(Debug, Clone)]
pub struct BTree<K: Ord, V> {
    root: Child<K, V>,
}

impl<K: Ord, V> BTree<K, V> {
    pub fn new() -> Self {
        Self {
            root: Child::Leaf(Box::new(NodeElements::new())),
        }
    }

    pub fn get<Q>(&self, key: &Q) -> Option<&V>
    where
        K: Borrow<Q>,
        Q: Ord + ?Sized,
    {
        fn rec<'a, K, V, Q>(child: ChildRef<'a, K, V>, key: &Q) -> Option<&'a V>
        where
            K: Borrow<Q> + Ord,
            Q: Ord + ?Sized,
        {
            match child {
                ChildRef::Node(node) => {
                    let mut child_idx = node.num_elements();

                    for (i, elem_k) in node.keys().iter().enumerate() {
                        if elem_k.borrow() == key {
                            return Some(&node.values()[i]);
                        } else if key < elem_k.borrow() {
                            child_idx = i;
                            break;
                        }
                    }

                    rec(node.children().get(child_idx).unwrap(), key)
                }
                ChildRef::Leaf(leaf) => {
                    for (i, elem_k) in leaf.keys().iter().enumerate() {
                        if elem_k.borrow() == key {
                            return Some(&leaf.values()[i]);
                        } else if key < elem_k.borrow() {
                            break;
                        }
                    }

                    None
                }
            }
        }

        rec(self.root.as_ref(), key)
    }

    pub fn get_mut<Q>(&mut self, key: &Q) -> Option<&mut V>
    where
        K: Borrow<Q>,
        Q: Ord + ?Sized,
    {
        fn rec<'a, K, V, Q>(child: ChildRefMut<'a, K, V>, key: &Q) -> Option<&'a mut V>
        where
            K: Borrow<Q> + Ord,
            Q: Ord + ?Sized,
        {
            match child {
                ChildRefMut::Node(node) => {
                    let mut child_idx = node.num_elements();

                    for (i, elem_k) in node.keys().iter().enumerate() {
                        if elem_k.borrow() == key {
                            return Some(&mut node.values_mut()[i]);
                        } else if key < elem_k.borrow() {
                            child_idx = i;
                            break;
                        }
                    }

                    rec(node.children_mut().drop_get_mut(child_idx).unwrap(), key)
                }
                ChildRefMut::Leaf(leaf) => {
                    for (i, elem_k) in leaf.keys().iter().enumerate() {
                        if elem_k.borrow() == key {
                            return Some(&mut leaf.values_mut()[i]);
                        } else if key < elem_k.borrow() {
                            break;
                        }
                    }

                    None
                }
            }
        }

        rec(self.root.as_mut(), key)
    }

    pub fn insert(&mut self, k: K, value: V) -> Option<(K, V)> {
        enum RecOut<K: Ord, V> {
            Replaced(K, V),
            LeafOverflow(K, V),
            NodeOverflow(K, V, Child<K, V>),
            Inserted,
        }

        fn rec<K: Ord, V>(mut child: ChildRefMut<K, V>, k: K, value: V) -> RecOut<K, V> {
            let child_idx = {
                let mut child_idx = child.num_elements();

                for (i, elem_k) in child.keys().iter().enumerate() {
                    if elem_k == &k {
                        return RecOut::Replaced(
                            k,
                            mem::replace(&mut child.values_mut()[i], value),
                        );
                    } else if &k < elem_k {
                        child_idx = i;
                        break;
                    }
                }
                child_idx
            };

            match child {
                ChildRefMut::Node(node) => {
                    let mut child = node.children_mut().drop_get_mut(child_idx).unwrap();
                    match rec(child.borrow_mut(), k, value) {
                        RecOut::Replaced(k, value) => RecOut::Replaced(k, value),
                        RecOut::Inserted => RecOut::Inserted,
                        RecOut::NodeOverflow(
                            rightmost_k,
                            rightmost_value,
                            rightmost_childs_child,
                        ) => {
                            let child = child.try_into_node().unwrap();
                            let (sep_k, sep_value, right) =
                                child.split(rightmost_k, rightmost_value, rightmost_childs_child);

                            if let Some((rightmost_k, rightmost_value, rightmost_child)) = node
                                .insert(child_idx, sep_k, sep_value, Child::Node(Box::new(right)))
                            {
                                RecOut::NodeOverflow(rightmost_k, rightmost_value, rightmost_child)
                            } else {
                                RecOut::Inserted
                            }
                        }
                        RecOut::LeafOverflow(rightmost_k, rightmost_value) => {
                            let child = child.try_into_leaf().unwrap();
                            let (sep_k, sep_value, right) =
                                child.split(rightmost_k, rightmost_value);

                            if let Some((rightmost_k, rightmost_value, rightmost_child)) = node
                                .insert(child_idx, sep_k, sep_value, Child::Leaf(Box::new(right)))
                            {
                                RecOut::NodeOverflow(rightmost_k, rightmost_value, rightmost_child)
                            } else {
                                RecOut::Inserted
                            }
                        }
                    }
                }
                ChildRefMut::Leaf(leaf) => {
                    let rightmost_element = leaf.insert(child_idx, k, value);

                    if let Some((rightmost_k, rightmost_value)) = rightmost_element {
                        RecOut::LeafOverflow(rightmost_k, rightmost_value)
                    } else {
                        RecOut::Inserted
                    }
                }
            }
        }

        match rec(self.root.as_mut(), k, value) {
            RecOut::Replaced(k, value) => Some((k, value)),
            RecOut::Inserted => None,
            RecOut::LeafOverflow(rightmost_k, rightmost_value) => {
                let root = self.root.try_as_leaf_mut().unwrap();
                let (sep_k, sep_value, right) = root.split(rightmost_k, rightmost_value);

                let left = mem::replace(root, Box::new(right));
                let new_root = Node::new(Child::Leaf(left));
                let right = mem::replace(&mut self.root, Child::Node(Box::new(new_root)))
                    .try_into_leaf()
                    .unwrap();

                self.root
                    .try_as_node_mut()
                    .unwrap()
                    .push(sep_k, sep_value, Child::Leaf(right))
                    .assert_none();

                None
            }
            RecOut::NodeOverflow(rightmost_k, rightmost_value, rightmost_child) => {
                let root = self.root.try_as_node_mut().unwrap();
                let (sep_k, sep_value, right) =
                    root.split(rightmost_k, rightmost_value, rightmost_child);

                let left = mem::replace(root, Box::new(right));

                let new_root = Node::new(Child::Node(left));
                let right = mem::replace(root, Box::new(new_root));

                root.push(sep_k, sep_value, Child::Node(right))
                    .assert_none();

                None
            }
        }
    }

    pub fn remove<Q>(&mut self, key: &Q) -> Option<(K, V)>
    where
        K: Borrow<Q>,
        Q: Ord + ?Sized,
    {
        fn resolve_underflow<K: Ord, V>(node: &mut Node<K, V>, child_idx: usize) {
            debug_assert!(
                node.children().get(child_idx).unwrap().num_elements() < MIN_NUM_ELEMENTS
            );

            let (keys, values, children) = node.get_all_mut();
            match children {
                ChildrenSliceMut::Nodes(children) => {
                    if let Some(donor_child) = children
                        .get_mut(child_idx + 1)
                        .filter(|child| MIN_NUM_ELEMENTS < child.num_elements())
                    {
                        let (mut removed_k, mut removed_value, mut removed_child) =
                            donor_child.remove(0);

                        mem::swap(&mut keys[child_idx], &mut removed_k);
                        mem::swap(&mut values[child_idx], &mut removed_value);

                        donor_child
                            .children_mut()
                            .drop_get_mut(0)
                            .unwrap()
                            .swap(removed_child.as_mut());

                        children[child_idx]
                            .push(removed_k, removed_value, removed_child)
                            .assert_none();
                    } else if let Some(donor_child) = child_idx
                        .checked_sub(1)
                        .map(|i| &mut children[i])
                        .filter(|child| MIN_NUM_ELEMENTS < child.num_elements())
                    {
                        let (mut removed_k, mut removed_value, removed_child) =
                            donor_child.pop().unwrap();

                        mem::swap(&mut keys[child_idx - 1], &mut removed_k);
                        mem::swap(&mut values[child_idx - 1], &mut removed_value);

                        children[child_idx]
                            .insert(0, removed_k, removed_value, removed_child)
                            .assert_none();
                        children[child_idx].children_mut().swap(0, 1);
                    } else {
                        let left = child_idx.saturating_sub(1);

                        let (sep_k, sep_value, right_child) = node.remove(left);

                        let left_child = &mut node.children_mut().try_into_nodes().unwrap()[left];

                        let right_child = right_child.try_into_node().unwrap();
                        let (right_elements, right_children) = right_child.separate();
                        let (right_ks, right_values) = right_elements.separate();

                        let mut right_children_iter = right_children.into_iter();

                        left_child
                            .push(sep_k, sep_value, right_children_iter.next().unwrap())
                            .assert_none();

                        for ((k, value), child) in right_ks
                            .into_iter()
                            .zip(right_values.into_iter())
                            .zip(right_children_iter)
                        {
                            left_child.push(k, value, child).assert_none();
                        }
                    }
                }
                ChildrenSliceMut::Leafs(children) => {
                    if let Some(donor_child) = children
                        .get_mut(child_idx + 1)
                        .filter(|child| MIN_NUM_ELEMENTS < child.len())
                    {
                        let (mut removed_k, mut removed_value) = donor_child.remove(0);

                        mem::swap(&mut keys[child_idx], &mut removed_k);
                        mem::swap(&mut values[child_idx], &mut removed_value);

                        children[child_idx]
                            .push(removed_k, removed_value)
                            .assert_none();
                    } else if let Some(donor_child) = child_idx
                        .checked_sub(1)
                        .map(|i| &mut children[i])
                        .filter(|child| MIN_NUM_ELEMENTS < child.len())
                    {
                        let (mut removed_k, mut removed_value) = donor_child.pop().unwrap();

                        mem::swap(&mut keys[child_idx - 1], &mut removed_k);
                        mem::swap(&mut values[child_idx - 1], &mut removed_value);

                        children[child_idx]
                            .insert(0, removed_k, removed_value)
                            .assert_none();
                    } else {
                        let left = child_idx.saturating_sub(1);

                        let (sep_k, sep_value, right_child) = node.remove(left);

                        let left_child = &mut node.children_mut().try_into_leafs().unwrap()[left];

                        let right_child = right_child.try_into_leaf().unwrap();
                        let (right_ks, right_values) = right_child.separate();

                        left_child.push(sep_k, sep_value).assert_none();

                        for (k, value) in right_ks.into_iter().zip(right_values.into_iter()) {
                            left_child.push(k, value).assert_none();
                        }
                    }
                }
            }

            debug_assert!(node
                .children()
                .iter()
                .all(|child| MIN_NUM_ELEMENTS <= child.num_elements()));
        }

        fn rem_smallest<K: Ord, V>(child: ChildRefMut<K, V>) -> ((K, V), bool) {
            match child {
                ChildRefMut::Node(node) => {
                    let (removed_kv, underflow) =
                        rem_smallest(node.children_mut().drop_get_mut(0).unwrap());

                    if underflow {
                        resolve_underflow(node, 0);
                    }
                    (removed_kv, node.num_elements() < MIN_NUM_ELEMENTS)
                }
                ChildRefMut::Leaf(leaf) => (leaf.remove(0), leaf.len() < MIN_NUM_ELEMENTS),
            }
        }

        fn rem_rec<K, V, Q>(child: ChildRefMut<K, V>, key: &Q) -> Option<((K, V), bool)>
        where
            K: Borrow<Q> + Ord,
            Q: Ord + ?Sized,
        {
            let child_idx = {
                let mut child_idx = child.num_elements();

                for (i, elem_k) in child.keys().iter().enumerate() {
                    let elem_q = elem_k.borrow();

                    if elem_q == key {
                        return match child {
                            ChildRefMut::Node(node) => {
                                let ((replacement_k, replacement_value), underflow) =
                                    rem_smallest(node.children_mut().drop_get_mut(i + 1).unwrap());

                                let removed_kv = (
                                    mem::replace(&mut node.keys_mut()[i], replacement_k),
                                    mem::replace(&mut node.values_mut()[i], replacement_value),
                                );

                                if underflow {
                                    resolve_underflow(node, i + 1);
                                }

                                Some((removed_kv, node.num_elements() < MIN_NUM_ELEMENTS))
                            }
                            ChildRefMut::Leaf(leaf) => {
                                Some((leaf.remove(i), leaf.len() < MIN_NUM_ELEMENTS))
                            }
                        };
                    } else if key < elem_q {
                        child_idx = i;
                        break;
                    }
                }
                child_idx
            };

            match child {
                ChildRefMut::Node(node) => {
                    let (removed_kv, underflow) =
                        rem_rec(node.children_mut().drop_get_mut(child_idx).unwrap(), key)?;

                    if underflow {
                        resolve_underflow(node, child_idx);
                    }
                    Some((removed_kv, node.num_elements() < MIN_NUM_ELEMENTS))
                }
                ChildRefMut::Leaf(_leaf) => None,
            }
        }

        match rem_rec(self.root.as_mut(), key) {
            Some((removed_kv, _underflow)) => {
                if self.root.num_elements() == 0 {
                    self.root.replace_with_child();
                }

                Some(removed_kv)
            }
            None => None,
        }
    }
}

impl<K: Ord, V> Default for BTree<K, V> {
    fn default() -> Self {
        Self::new()
    }
}
